# JVM 메모리

[[Java] 자바 JVM 내부 구조와 메모리 구조에 대하여](https://coding-factory.tistory.com/828)

.java 파일들을 컴파일해 class 파일로 바꾼다.

- JVM에 사용 가능 메모리를 할당해 주는 역할은 OS가 담당한다.

이후 ‘클래스 로더’ 라는 녀석이 JVM에 클래스들을 넣어준다. 

JVM 의 메모리 영역은 

![Untitled](JVM%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20c1bdb3c05cc045298f700183d256ebd6/Untitled.png)

다음과 같이 생겼고, 클래스 로더는 Method Area 에 클래스들에 대한 정보를 저장한다.

이후 코드에서 new 를 통해 객체를 생성하게 되면 Method Area에 있는 클래스의 내용들을 복사?해와 Heap 영역에 저장한다.

[[JAVA/자바] 메모리 구조(static, stack, heap)](https://m.blog.naver.com/heartflow89/220954420688)

이후의 이야기가 바로 이 블로그의 내용인 것 같은데, 처음에 잘 이해를 못해 객체를 생성할 때 마다 저 메모리 영역이 각각 할당 되는줄 알았다. 틀린말은 아닌데, 객체를 생성할 때마다 생성되는 메모리 영역은 method Area 에서 복사해 Heap에 저장하는 공간과, 그에 딸려오는 Stack 영역인 것이었다.

우리가 전역변수, Static 변수들은 어느 곳에서나 이용할 수 있는 것으로 알고 있는데, 이는 처음 클래스 로더에 의해 method area에 저장된 전역변수, static 변수들은 새로 클래스가 생성 돼 Heap 영역으로 갈 때 복사되지 않기 때문이다. 이 변수들은 Method Area에 저장된 값으로 참조를 하기 때문에 다른 객체에서 이 값을 수정할 경우 또다른 객체에도 수정된 값으로 보이는 것이다.

그러면 메모리 초과에 대한 내 걱정도 해결이 되는것이다.

나는 생성한 객체들이 다 메모리를 잡아먹어서 문제가 생기는 것을 걱정하였다. 

이 답은 , 객체를 생성할 때마다 method area에서 가져와 heap에 저장하고, 또 생성하면 다시 가져오는 것이다.

나처럼 변수명은 똑같이 하여 계속 가져온다면, 이전에 heap에 저장되었던 영역은 아무런 참조를 받지 않는 상태가 된다. 그럼 자연스럽게 가비지 컬렉터에 의해 정리가 된다.

만약에 변수명을 바꿔서 계속 객체를 생성하면 언젠간 heap 영역이 초과가 되겠지. 이 짓은 하면 안되는 것이다!